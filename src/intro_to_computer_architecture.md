# 淺談電腦的運作方式

這裡會簡單的、不嚴謹的介紹「電腦」運作的方式，或者說是程式運作的方式。需要特別提到的是，這裡所談的「電腦」、「程式」可能跟你們所想像的有點不一樣。這裡將會從一個「概念上」的角度去看「電腦」與「程式」，或者說這裡談的是電腦的「原型（Prototype）」或者說是「雛型」，這裡談的電腦很接近早期的電腦。希望這一章節所提到的概念會有助於之後編寫程式的學習。

## 程式與指令

什麼是程式？其實程式就只是一長串的「指令」而已。那麼什麼是「指令」呢？概念上來看，每個指令就代表一個動作，你可以想成是當電腦讀到這個指令後就會完成那個動作。所以如果你以某種方式餵給電腦一串指令，可以想象的是電腦就會完成一串動作。

通常指令有下面這幾種

* 記憶體操作：像是把某個數字放到記憶體的某個位址（後面會介紹什麼是記憶體）。
* 邏輯、數學運算：像是加、減法。
* 控制流程：控制接下來要執行哪個指令。


## 電腦的組成

再重申一次，這裡說的電腦只是「概念上」的電腦。以概念上的電腦來說，只要有 CPU, RAM, ROM 就可以進行運算了。當然，在現代的電腦裡，一定有更多的元件，像是硬碟、顯示卡等等，然而這些東西的加入會讓一切都變得太複雜，所以將不會在討論範圍裡。

### 記憶體（RAM、ROM）

可以把記憶看成是一張很大張的試算表，也就是一大張有格子的紙，每一個格子都可以放固定大小的資料（可以理解成是固定上下限的整數，像是 -65535 到 65535 的數字）。正如在「Google 試算表」或是「Excel」所看到的，每一個格子都有一個編號，我們稱之為「記憶體位址」。而 RAM 和 ROM 的差別在於， RAM 上面的每一個格子是可以被動態更改的，而 ROM 則不能。在古早古早的年代，程式就是被「燒」進去 ROM 裡的。某種程度上來說，把程式「燒到」 ROM 裡這件事在現在還是常見的，像是遊戲光碟就是一塊燒著程式的 ROM（不過裡面程式的執行方式已大不相同）。

### 中央處理器（CPU）

中央處理器是電腦裡真正在做運算的元件，他做的事就是執行 ROM 上某個位址的指令。大部分的資料都是儲存在 RAM 或 ROM 上，但 CPU 裡有一塊特殊的記憶體叫做「程式計數器（Program Counter）」，這塊記憶體裡就存一個整數，記錄了 CPU 下一個要執行的指令的位址。

## 程式的執行

所以 CPU 會有點像是這樣運作的

* 看看程式計數器記錄的數字——為了方便，我們說那個數字是 $$x$$ 好了
* 然後執行 ROM 裡位址 $$x$$ 的那個格子裡的指令

大多數時候 CPU 執行完一個指令後這個計數器就會自動增加 1，而通常這個數字在一開始的時候是 0，所以 CPU 做的事會像這樣

* 看看程式計數器記錄的數字——為了方便，我們說那個數字是 $$x$$ 好了
* 然後執行 ROM 裡位址 $$x$$ 的那個格子裡的指令
* 程式計數器記錄的數字增加 1
* 看看程式計數器記錄的數字——為了方便，我們說那個數字是 $$x$$ 好了
* 然後執行 ROM 裡位址 $$x$$ 的那個格子裡的指令
* 程式計數器記錄的數字增加 1
* 看看程式計數器記錄的數字——為了方便，我們說那個數字是 $$x$$ 好了
* 然後執行 ROM 裡位址 $$x$$ 的那個格子裡的指令
* 程式計數器記錄的數字增加 1
* ...

帶入數字的話變成

* 看看程式計數器記錄的數字——為了方便，我們說那個數字是 $$x$$ 好了 （一開始的時候 $$x$$ 是 $$0$$）
* 然後執行 ROM 裡位址 $$x$$ 的那個格子裡的指令 （執行位址 $$0$$ 的指令）
* 程式計數器記錄的數字增加 1
* 看看程式計數器記錄的數字——為了方便，我們說那個數字是 $$x$$ 好了 （$$x$$ 是 $$1$$）
* 然後執行 ROM 裡位址 $$x$$ 的那個格子裡的指令 （執行位址 $$1$$ 的指令）
* 程式計數器記錄的數字增加 1
* 看看程式計數器記錄的數字——為了方便，我們說那個數字是 $$x$$ 好了 （$$x$$ 是 $$2$$）
* 然後執行 ROM 裡位址 $$x$$ 的那個格子裡的指令 （執行位址 $$2$$ 的指令）
* 程式計數器記錄的數字增加 1
* ...

也就是說，「程式計數器」讓 CPU 把 ROM 上的指令一個一個**照順序**的執行下去了！

## 流程控制（Control Flow）

還記得前面在介紹指令時，有一類指令就是「流程控制」嗎？前面提過，流程控制的指令是用來控制接下來要執行哪一個指令的。那麼，你可以猜到這類指令是在做什麼了嗎？其實這類指令做的事就是去修改「程式計數器」。

所以，假設現在有一個指令叫做 `JMP addr` ，後面的 `addr` 是一個數字，意思是把「程式計數器」記錄的數字改成 `addr`，並防止「程式計數器」在執行完這個指令後自動加一，例如執行 `JMP 10` 就會把「程式計數器」設成 10。

現在我們來看看如果位址 2 的指令是 `JMP 0` 的話會怎樣：

* 看看程式計數器記錄的數字——為了方便，我們說那個數字是 $$x$$ 好了 （一開始的時候 $$x$$ 是 $$0$$）
* 然後執行 ROM 裡位址 $$x$$ 的那個格子裡的指令 （執行位址 $$0$$ 的指令）
* 程式計數器記錄的數字增加 1
* 看看程式計數器記錄的數字——為了方便，我們說那個數字是 $$x$$ 好了 （$$x$$ 是 $$1$$）
* 然後執行 ROM 裡位址 $$x$$ 的那個格子裡的指令 （執行位址 $$1$$ 的指令）
* 程式計數器記錄的數字增加 1
* 看看程式計數器記錄的數字——為了方便，我們說那個數字是 $$x$$ 好了 （$$x$$ 是 $$2$$）
* 然後執行 ROM 裡位址 $$x$$ 的那個格子裡的指令 （執行位址 $$2$$ 的指令：`JMP 0`）
* 程式計數器記錄的數字**變成 0**
* 看看程式計數器記錄的數字——為了方便，我們說那個數字是 $$x$$ 好了 （一開始的時候 $$x$$ 是 $$0$$）
* 然後執行 ROM 裡位址 $$x$$ 的那個格子裡的指令 （執行位址 $$0$$ 的指令）
* 程式計數器記錄的數字增加 1
* 看看程式計數器記錄的數字——為了方便，我們說那個數字是 $$x$$ 好了 （$$x$$ 是 $$1$$）
* 然後執行 ROM 裡位址 $$x$$ 的那個格子裡的指令 （執行位址 $$1$$ 的指令）
* 程式計數器記錄的數字增加 1
* 看看程式計數器記錄的數字——為了方便，我們說那個數字是 $$x$$ 好了 （$$x$$ 是 $$2$$）
* 然後執行 ROM 裡位址 $$x$$ 的那個格子裡的指令 （執行位址 $$2$$ 的指令：`JMP 0`）
* 程式計數器記錄的數字**變成 0**
* 看看程式計數器記錄的數字——為了方便，我們說那個數字是 $$x$$ 好了 （一開始的時候 $$x$$ 是 $$0$$）
* 然後執行 ROM 裡位址 $$x$$ 的那個格子裡的指令 （執行位址 $$0$$ 的指令）
* 程式計數器記錄的數字增加 1
* 看看程式計數器記錄的數字——為了方便，我們說那個數字是 $$x$$ 好了 （$$x$$ 是 $$1$$）
* 然後執行 ROM 裡位址 $$x$$ 的那個格子裡的指令 （執行位址 $$1$$ 的指令）
* 程式計數器記錄的數字增加 1
* 看看程式計數器記錄的數字——為了方便，我們說那個數字是 $$x$$ 好了 （$$x$$ 是 $$2$$）
* 然後執行 ROM 裡位址 $$x$$ 的那個格子裡的指令 （執行位址 $$2$$ 的指令：`JMP 0`）
* 程式計數器記錄的數字**變成 0**
* ...

我們可以看到，當執行完第二個指令後， CPU 馬上又「跳」回執行第 0 個指令了，於是就形成一個「迴圈」，而且永遠出不來。

## 條件判斷

為了讓電腦能做更多事，通常還會有其他的「流程控制」指令，如 `JEQ`, `JLT`, `JGT`，這三個指令會先去檢查 RAM 的某個位址的值是不是有符合某種條件，如果有的話才更改「程式計數器」的值，沒有的話就讓「程式計數器」照原來的樣子增加 1。

這三個指令的檢查的條件分別是

* JEQ：等於 0。
* JLT：小於 1。
* JGT：大於 1。

## 小結

其實這些指令們都很簡單，然而拼湊起來將會可以變出複雜的程式。
